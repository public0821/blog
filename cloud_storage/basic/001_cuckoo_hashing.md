# Cuckoo Hashing概述

最近在研究Cuckoo Filter, 于是将hash表相关的数据结构重新学习了一下，在这里将自己的理解整理下来，仅供参考。

本文将先介绍Cuckoo Hashing，后续会介绍Bloom Filter和Cuckoo Filter。

## 传统Hashing
在当前主流的开发语言中，都有现成的基于哈希表的key/value map来存储数据，如HashMap(Java), dict(Python), unordered_map(C++), map(Go), 相对于基于平衡二叉树的map(如Java的TreeMap，C++的map)，基于哈希表的map不是有序的，但是它的插入查找速度要快（前提条件是hash函数设置的比较合理）。 

对于hash冲突，当前主要的有两种解决办法，一种是Open Addressing，一种是Chaining

### Open Addressing
当发现冲突之后，在hash表的其它位置再找一个空闲的位置来放置新的元素，怎么再找一个新的位置呢？有很多种办法，比如linear probing，quadratic probing等，哪种方法好取决于数据的特点，但目的都是要尽可能的减少冲突，并尽可能的将hash值一样的数据放在一起来利用CPU cache提高性能，这里以线性探测为例，介绍一下冲突解决的办法。

为了简单起见，这里假设哈希表的长度为10（在具体实现的时候，长度一般是质数，这样可以让数据更分散，减少冲突）

#### 插入
假设hash表的长度是10， 里面已经有了21，12，35, 60四个数据，现在我们想插入22，23，24
```
   0   1    2    3    4    5    6    7    8     9
+----+----+----+----+----+----+----+----+----+----+
| 60 | 21 | 12 |    |    | 35 |    |    |    |    |
+----+----+----+----+----+----+----+----+----+----+
```
第一步，插入22，由于位置已经被12占了，于是只能往后挪一步，放到3的位置
```
   0   1    2    3    4    5    6    7    8     9
+----+----+----+----+----+----+----+----+----+----+
| 60 | 21 | 12 | 22 |    | 35 |    |    |    |    |
+----+----+----+----+----+----+----+----+----+----+
```
插入23，由于位置已经被22占了，只能往后挪一步，放到4的位置
```
   0   1    2    3    4    5    6    7    8     9
+----+----+----+----+----+----+----+----+----+----+
| 60 | 21 | 12 | 22 | 23 | 35 |    |    |    |    |
+----+----+----+----+----+----+----+----+----+----+
```
插入24，由于位置已经被23占了，只能往后挪，由于下一个位置被35占了，只能继续往后挪，最后放到了6的位置
```
   0   1    2    3    4    5    6    7    8     9
+----+----+----+----+----+----+----+----+----+----+
| 60 | 21 | 12 | 22 | 23 | 35 | 24 |    |    |    |
+----+----+----+----+----+----+----+----+----+----+
```
想象一下现在要插入31，就需要挪到7的位置。

#### 查找
查找的时候跟插入的时候一样，比如要找24，发现4的位置是23，于是继续挨个的往后找，直到6为止。

如果是查找一个不存在的值呢？比如查找31，发现1的位置是不是31，于是挨个的往后找，直到走到7的位置，发现是空的，才表示当前哈希表中没有31.

#### 删除

当待删除的数据后面有数据时，只能标记为已删除，但不能真正的删除掉该数据，不然会导致后面的数据有可能找不到，比如删除35，如果35被真正的删除掉了之后，就会变成下面的样子
```
   0   1    2    3    4    5    6    7    8     9
+----+----+----+----+----+----+----+----+----+----+
| 60 | 21 | 12 | 22 | 23 |    | 24 |    |    |    |
+----+----+----+----+----+----+----+----+----+----+
```
当再查找24的时候，首先看4的位置不是24，再往后找，发现5的位置是空的，于是返回24不存在，但实际上24是在哈希表中的。

### Chaining

这种方法比较直观，根据hash code找到对应的位置（一般称为bucket），然后在位置后面的linked list中添加，查找，删除元素即可。

初始状态：
```
   0     1     2     3     4     5     6     7     8     9
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
|     |     |     |     |     |     |     |     |     |     |
+--↓--+--↓--+--↓--+-----+-----+--↓--+-----+-----+-----+-----+
   ↓     ↓     ↓                 ↓
 +--+  +--+  +--+              +--+
 |60|  |21|  |12|              |35|
 +--+  +--+  +--+              +--+
```
插入22，23，24之后
```
   0      1     2     3     4     5     6     7     8     9
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
|     |     |     |     |     |     |     |     |     |     |
+--↓--+--↓--+--↓--+--↓--+--↓--+--↓--+-----+-----+-----+-----+
   ↓     ↓     ↓     ↓     ↓     ↓
 +--+  +--+  +--+  +--+  +--+  +--+
 |60|  |21|  |12|  |23|  |24|  |35|
 +--+  +--+  +--+  +--+  +--+  +--+
         ↓
       +--+
       |22|
       +--+
```
### 特点
两种方法都有一个缺点，就是都没法控制最坏情况下的性能。

#### Open Addressing
* 当表里面的数据过满的时候，性能会大幅度的下降，比如哈希表满了之后，就会退化为O(n)的复杂度，所以一般实现的时候会在哈希表的使用率达到50%的时候，进行rehash。
* 相同哈希值的数据存储在连续的地址空间中，可以充分利用cpu的cache，一次读取一批数据，然后进行比较

#### Chaining
* 插入，查找，删除的时候都只会和同自己hash code一样的数据进行比较，减少了比较次数
* 一般只会在linked list过长的时候才会rehash，理论上空间利用率较高

## Cuckoo Hashing
Cuckoo Hashing的最大特点就是能保证最坏情况下的查找性能能达到O(1)。

Cuckoo Hashing采用两张hash表和两个hash函数，为了简单起见，假设第一个hash函数func1是取数字的十位数，第二个hash函数func2取个位数，那么对于数字25来说，func1(25) = 2, func2(25) = 5，同理func1(5) = 0, func2(5) = 5, func1(125) = 2, func2(125) = 5。

### 插入
下面我们依次插入5, 25, 28, 8, 125,看看结果

* func1(5) = 0, func2(5) = 5，它可以放在T1的第0个位置和T2的第5个位置，我们这里选择T1表优先（具体实现时哪个表优先都可以）
```
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T1: | 5  |    |    |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T2: |    |    |    |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+

```

* func1(25) = 2, func2(25) = 5，它可以放在T1的第2个位置和T2的第5个位置，T1表优先，于是放到T1的2号位置
```
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T1: | 5  |    | 25 |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T2: |    |    |    |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+

```

* func1(28) = 2, func2(28) = 8，它可以放在T1的第2个位置和T2的第8个位置，但由于T1表的2号位已经被占了，现在有两种选择，一种是抢占2的位置，另一种是优先空位置，这里我们采取优先空位置的策略，将28放入T2的8号位
```
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T1: | 5  |    | 25 |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T2: |    |    |    |    |    |    |    |    | 28 |    |
    +----+----+----+----+----+----+----+----+----+----+

```

* func1(8) = 0, func2(8) = 8，它可以放在T1的第0个位置和T2的第8个位置，但不幸的是两个位置都被人占了，于是它得抢一个，那是抢5的位置还是28的位置呢，在实现的时候一般是随机的，这里假设抢28的位置，于是28被拿出来，将8放进去
```
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T1: | 5  |    | 25 |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T2: |    |    |    |    |    |    |    |    |  8 |    |
    +----+----+----+----+----+----+----+----+----+----+

```

    那28怎么办呢？它只能去抢25的位置，于是25被拿出来，放入28
```
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T1: | 5  |    | 28 |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T2: |    |    |    |    |    |    |    |    |  8 |    |
    +----+----+----+----+----+----+----+----+----+----+

```

    还好25还有一个空位置，于是被放入T2的5号位
```
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T1: | 5  |    | 28 |    |    |    |    |    |    |    |
    +----+----+----+----+----+----+----+----+----+----+
       0   1    2    3    4    5    6    7    8     9
    +----+----+----+----+----+----+----+----+----+----+
T2: |    |    |    |    |    | 25 |    |    |  8 |    |
    +----+----+----+----+----+----+----+----+----+----+

```

* func1(125) = 2, func2(125) = 5，这个路径就会更长，并且不论是选择先抢28还是25的位置，都会发现会进入一个环，没有空位置可用，这个时候就需要进行re-hash，否则插入数据就会失败

### 查找
查找很简单，比如要查找25，只需查看T1的2号位和T2的5号位，如果25在这两个位置的任意一个，查找成功，否则失败。

### 删除
删除和查找一样，找到对应的数据，然后删掉即可

### 总结
在具体实现的时候，为了优化性能，可能会和这里描述的有一些细微的不同，但总体思路是一样的。为了减少冲突，在实现时可以选择多于两张hash表，或者hash表的一个位置放多个数据，由于计算hash值比较耗CPU，一般会选择第二种方法，比如上面的例子，如果一个位置可以放两个值得话，插入125就没有问题，它可以和25或者28放在一起。

* 插入的速度取决于冲突的情况，有时可能会比较差
* 查找的时候只需要检查两个位置，速度快
* 空间利用率高，由于采取多个hash函数，有多个hash表，冲突的几率比较低

跟传统的Hashing算法相比，Cuckoo Hashing有更好的查找性能和空间利用率，非常适合查找频率大于插入频率的场合。

## 参考

* [Cuckoo Hashing](https://www.cs.tau.ac.il/~shanir/advanced-seminar-data-structures-2009/bib/pagh01cuckoo.pdf)
* [Cuckoo Hashing的应用及性能优化](https://yq.aliyun.com/articles/563053)

